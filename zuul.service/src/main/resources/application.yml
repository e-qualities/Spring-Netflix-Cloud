---
spring:
  application:
    name: zuul-service

server:
  port: ${PORT:8888}
  servlet.session.cookie.name: ZUULSESSION 
  
# Local Setup: with an OAuth 2.0 server running locally.
security:
  oauth2:
    client:
       clientId: client-1
       clientSecret: client-1-secret
       accessTokenUri: http://localhost:10080/oauth/token
       userAuthorizationUri: http://localhost:10080/oauth/authorize
    resource:
      jwk:
        key-set-uri: http://localhost:10080/.well-known/jwks.json
      # Also possible: hard code the public key of the server used for JWT signature validation.
      # jwt:
      #   key-value: "-----BEGIN PUBLIC KEY-----MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwThn6OO9kj0bchkOGkqYBnV1dQ3zU/xtj7Kj7nDd8nyRMcEWCtVzrzjzhiisRhlrzlRIEY82wRAZNGKMnw7cvCwNixcfcDJnjzgr2pJ+5/yDZUc0IXXyIWPZD+XdL+0EogC3d4+fqyvg/BF/F0t2hKHWr/UTXE6zrGhBKaL0d8rKfYd6olGWigFd+3+24CKI14zWVxUBtC+P9Fhngc9DRzkXqhxOK/EKn0HzSgotf5duq6Tmk9DCNM4sLW4+ERc6xzrgbeEexakabvax/Az9WZ4qhwgw+fwIhKIC7WLwCEJaRsW4m7NKkv+eJR2LKYesuQ9SVAJ3EXV86RwdnH4uAv7lQHsKURPVAQBlranSqyQu0EXs2N9OlWTxe+FyNkIvyZvoLrZl/CdlYc8AKxRm5rn2/88nkrYQ0XZSrnICM5FRWgVF2hn5KfZGwtBN85/D4Yck6B3ocMfyX7e4URUm9lRPQFUJGTXaZnEIge0R159HUwhTN1HvyXrs6uT1ZZmW+c3p47dw1+LmUf/hIf8zd+uvHQjIeHEJqxjqfyA8yqAFKRHKVFrwnwdMHIsRap2EKBhHMfeVf0P2th5C9MggYoGCvdIaIUgMBX3TtCdvGrcWML7hnyS2zkrlA8SoKJnRcRF2KxWKs355FhpHpzqyZflO5l98+O8wOsFjGpL9d0ECAwEAAQ==-----END PUBLIC KEY-----"
      #   key-uri: https://d056076-sub1.authentication.eu10.hana.ondemand.com/token_keys
     
# Remote Setup: with an OAuth 2.0 server on SAP CP CF:
#security:
#  oauth2:
#    client:
#      clientId: <your client ID as seen in VCAP_SERVICES>                                                               
#      clientSecret: <your client secret as seen in VCAP_SERVICES>                                                        
#      accessTokenUri: https://<your subaccount domain>.authentication.eu10.hana.ondemand.com/oauth/token            
#      userAuthorizationUri: https://<your subaccount domain>.authentication.eu10.hana.ondemand.com/oauth/authorize
#    resource:
#      jwk:
#        key-set-uri: https://<your subaccount domain>.authentication.eu10.hana.ondemand.com/token_keys

# Setting security log levels for debugging
logging.level:
  org.springframework.security: DEBUG 

# eureka configurations
eureka:
  instance:
    leaseRenewalIntervalInSeconds: 2  # only for local development. remove this setting in production and thus default to 30 seconds.
    metadata-map:
      zone: AWS-EU-FRA    # Specify the zone this service is running in. Used to match clients in the same zone first.
      cluster: DEV        # For Turbine clustering.
  client: 
    serviceUrl:
      defaultZone: http://localhost:8761/eureka

# configurations of the actuator /info endpoint
info: 
  app:
    name: "Zuul Edge Router"
    description: "An edge router component based on Netflix Zuul."
    
management.endpoints.web.exposure.include: "*"
management.endpoint.health.show-details: always 

# Hystrix and Ribbon configurations
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 6500
ribbon:
  ConnectTimeout: 1000              # timeout for establishing a connection.
  ReadTimeout: 2000                 # timeout for receiving data after connection is established.
  MaxAutoRetries: 1                 # maximum number of retries ribbon will attempt in case of timeouts or errors.
  MaxAutoRetriesNextServer: 0       # maximum number of other service instances to retry.
  OkToRetryOnAllOperations: false   # disable retries for POST operations
  retryableStatusCodes: 404,500     # retry when receiving these response status codes. Requires Spring Retry on the classpath.

# Zuul configurations
zuul:
  sensitiveHeaders: Cookie,Set-Cookie # Blacklist only Cookie and Set-Cookie header, so that Zuul does not forward them to the client and vice versa. The default is Cookie,Set-Cookie,Authorization, but we need the Authorization Header, as JWT Tokens need to be forwarded to downstream services. See also: https://cloud.spring.io/spring-cloud-netflix/multi/multi__router_and_filter_zuul.html#_cookies_and_sensitive_headers
  ignoredPatterns: /actuator/**       # don't try forwarding requests that are pointed at /actuator/**, since this is Zuuls own actuator endpoint.
  
  groovyFiltersPath:                # This is not an official Zuul configuration. It is added by GroovyFilterPathConfig and used by GroovyFiltersInitializer.
    - groovy/pre                    # See: https://stackoverflow.com/questions/49289584/spring-cloud-zuul-and-groovy-filters
    - groovy/route                  # Allows reading filters in Groovy from disk and refresh them at runtime without restarting Zuul.
    - groovy/post                   # Use this with extreme care, as with Groovy you could bring down the server, too.
    - groovy/error                  

#  decodeUrl: false                # see: https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/single/spring-cloud-netflix.html#_request_uri_encoding
#  ribbonIsolationStrategy: THREAD # set the Hystrix isolation strategy 'THREAD' for all routes (see https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-ribbon.html#how-to-configure-hystrix-thread-pools)  
#  ignoreSecurityHeaders: false    # - use in combination with Spring Security if you want security headers set by BE services.
#  sensitiveHeaders:               # - will allow ALL headers to be forwarded by Zuul. Use this with care!                                   
#  ignoredServices: '*'            # - will not forward any requests.
#  <SimpleClassName>               # See: https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/single/spring-cloud-netflix.html#_disable_zuul_filters
#    <filterType>.disable: true    # List of filters: https://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-zuul/src/main/java/org/springframework/cloud/netflix/zuul/filters
#
#  routes:
#    address-service:              # name of the service as found in Eureka registry
#      path: /addresses/**         # path to map it to.
#      #stripPrefix: false         # - will forward the path prefix to the target service
#    employee-service:             # name of the service as found in Eureka registry
#      path: /employees/**         # path to map it to.
#      #stripPrefix: false         # - will forward the path prefix to the target service        
#    legacy:                       # some legacy service path to map it to. 
#      path: /**                   # Note: this path is containing the paths above and therefore needs to be specified last as otherwise it would override the other paths.  
#      serviceId: old_address      # the name of the service as found in Eureka registry 
#    external:
#      path: /external/**
#      url: http://example.com/external_service          # route to an external URL. This is NOT using hystrix by default. See: https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/single/spring-cloud-netflix.html#netflix-zuul-reverse-proxy
#      sensitiveHeaders: Cookie,Set-Cookie,Authorization # make sure these headers are not forwarded to the external service - they are probably making problems anyway, see: https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/single/spring-cloud-netflix.html#_cookies_and_sensitive_headers

#################################################################################################################
#  Strangulation Pattern - to slowly replace legacy. As a temporary solution you provide routes that forward    #
#  old service clients to new service implementations. Once no old clients are left you can remove the tempo-   #
#  rary routes.                                                                                                 #
#################################################################################################################
# See: https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.1.0.RELEASE/single/spring-cloud-netflix.html#_strangulation_patterns_and_local_forwards
#zuul:
#  routes:
#    first:
#      path: /first/**
#      url: http://first.example.com
#    second:
#      path: /second/**
#      url: forward:/second
#    third:
#      path: /third/**
#      url: forward:/3rd
#    legacy:
#      path: /**
#      url: http://legacy.example.com

---
spring.profiles: cloud

eureka:
  client: 
    serviceUrl:
      defaultZone: ${eureka-server-url}/eureka  # URL of the form https://<unique prefix>-eureka-server.cfapps.eu10.hana.ondemand.com/eureka
                                                # Resolved from environment set in manifest.yml
  instance:
    ## This information will be part of the InstanceInfo returned by DiscoveryClient / EurekaClient.
    ## Unfortunately, these have to be specified explicitly, since Eureka creates these URLs wrongly
    ## when running on CF. 
    ## See: https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html
    homePageUrl:          https://${vcap.application.uris[0]:localhost}/   
    statusPageUrl:        https://${vcap.application.uris[0]:localhost}/actuator/info 
    healthCheckUrl:       https://${vcap.application.uris[0]:localhost}/actuator/health
    secureHealthCheckUrl: https://${vcap.application.uris[0]:localhost}/actuator/health
    ## set the host name explicitly when in Cloud Foundry.
    hostname:             ${vcap.application.uris[0]:localhost}
    nonSecurePortEnabled: false
    securePortEnabled:    true
    securePort:           443
    #nonSecurePort:       80
    #preferIpAddress:     true
    metadataMap:
      instanceId: ${vcap.application.instance_id:-}




